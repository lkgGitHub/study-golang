

面向对象编程(OOP)

## 方法申明
在函数声明时，在其名字之前放上一个变量，即是一个方法。这个附加的参数会将该函数附加到这种类型上，即相当于为这种类型定义了一个独占的方法。

包级别的函数
方法调用

# 2. 基于指针对象的方法

1. 一般会约定如果Point这个类有一个指针作为接收器的方法，那么所有Point的方法都必须有一个指针接收器，即使是那些并不需要这个指针接收器的函数
2. 如果接收器p是一个Point类型的变量，并且其方法需要一个Point指针作为接收器，我们可以用下面这种简短的写法。。编译器会隐式地帮我们用&p去调用ScaleBy这个方法
```go
// 此表达式叫做"选择器"， p.ScaleBy为"接收器"
p.ScaleBy(2)
```
3. 不管你的method的receiver是指针类型还是非指针类型，都是可以通过指针/非指针类型进行调用的，编译器会帮你做类型转换。
4. 在声明一个method的receiver该是指针还是非指针类型时，你需要考虑两方面的因素，
第一方面是这个对象本身是不是特别大，如果声明为非指针变量时，调用会产生一次拷贝；
第二方面是如果你用指针类型作为receiver，那么你一定要注意，这种指针类型指向的始终是一块内存地址
所有方法都是用T类型自己来做接收器（而不是*T），那么拷贝这种类型的实例就是安全的；调用他的任何一个方法也就会产生一个值的拷贝
5. Nil也是一个合法的接收器类型

# 通过嵌套结构体来扩展类型
内嵌字段会指导编译器去生成额外的包装方法来委托已经声明好的方法

            
# 4. 方法值和方法表达式
p.Distance叫作“选择器”，选择器会返回一个方法“值”->一个将方法（Point.Distance）绑定到特定接收器变量的函数。
当调用一个方法时，与调用一个普通的函数相比，我们必须要用选择器（p.Distance）语法来指定方法的接收器。

# 5. 示例: Bit数组
Go语言里的集合一般会用map[T]bool这种形式来表示，T代表元素类型。

fmt会直接调用用户定义的String方法。这种机制依赖于接口和类型断言

# 6. 封装
Go语言只有一种控制可见性的手段：大写首字母的标识符会从定义它们的包中被导出，小写字母的则不会。
这种限制包内成员的方式同样适用于struct或者一个类型的方法
因而如果我们想要封装一个对象，我们必须将其定义为一个struct。

封装的好处：
1. 因为调用方不能直接修改对象的变量值，其只需要关注少量的语句并且只要弄懂少量变量的可能的值即可。
2. 隐藏实现的细节，可以防止调用方依赖那些可能变化的具体实现，这样使设计包的程序员在不破坏对外的api情况下能得到更大的自由。
3. 是阻止了外部调用方对对象内部的值任意地进行修改